# Java-Interview-Preparation
## 1. Java Compilation and Related Concepts. How Does Java Compile?
Java combines both compilation and interpretation, making it a hybrid language. Here's how the Java compilation and execution process works:

1. **Source Code Compilation (Compile Time)**
    - Java source code is written in `.java` files.
    - This source code is compiled by the Java Compiler (`javac`) into an intermediate form called bytecode.
    - Bytecode is stored in `.class` files, which are platform-independent.

    **Key Point:** The compilation process is similar to other compiled languages like C++ but results in bytecode instead of machine code.

2. **Execution (Runtime)**
    - #### Interpretation via the JVM
    - Bytecode is executed by the Java Virtual Machine (JVM).
    - The JVM interprets the bytecode and translates it into machine code for the specific platform.

3. **Just-In-Time (JIT) Compilation**
    - Modern JVMs use a Just-In-Time (JIT) compiler.
    - The JIT compiler converts frequently executed bytecode into native machine code during runtime.
    - This machine code is cached, improving performance for subsequent executions.

    **Key Point:** The JVM allows Java to be platform-independent ("write once, run anywhere") because the same bytecode can run on any device with a compatible JVM.

---

### Is Java Compiled or Interpreted?
**Both.**
- Java is compiled into bytecode by the `javac` compiler.
- Java bytecode is then interpreted or JIT-compiled into machine code by the JVM.

This dual approach offers a balance between portability (due to bytecode) and performance (due to JIT compilation).

---

## 2. What is the JIT Compiler?
The Just-In-Time (JIT) Compiler is a component of the JVM that improves the performance of Java applications by converting bytecode into native machine code at runtime.

### How the JIT Compiler Works:
1. **Bytecode Execution by the JVM:**
   - Java code is compiled into platform-independent bytecode by the Java compiler (`javac`).
   - The JVM interprets this bytecode line by line, which can be slower for repetitive operations.

2. **Role of the JIT Compiler:**
   - The JIT compiler identifies sections of code that are frequently executed, such as loops or methods, during runtime.
   - These "hot" sections of bytecode are then compiled into native machine code specific to the host operating system and processor.
   - Once compiled, the native machine code is executed directly, bypassing interpretation, which speeds up performance.

3. **Caching Machine Code:**
   - The machine code generated by the JIT compiler is cached, so subsequent executions of the same code block are faster since no re-interpretation or recompilation is needed.

### Advantages of JIT Compilation:
- **Improved Performance:** Native machine code runs significantly faster than interpreted bytecode.
- **Optimization:** The JIT compiler applies various runtime optimizations, such as inlining methods, removing redundant code, and optimizing memory usage.
- **Dynamic Adaptation:** The JIT compiler can optimize code based on actual runtime conditions, unlike static compilation.

---

## 3. How Is Java Platform Independent? What is Bytecode?
Java is considered platform-independent because its programs can run on any operating system or hardware that has a compatible JVM.

### Key Factors Behind Platform Independence:
#### Compilation to Bytecode:
- Java source code (`.java` files) is compiled by the Java compiler (`javac`) into an intermediate, platform-independent format called bytecode (`.class` files).
- Bytecode is not tied to any specific machine architecture or operating system.

#### Execution by the JVM:
- The bytecode is executed by the JVM, which translates it into native machine code for the specific platform during runtime.
- Every platform (Windows, macOS, Linux, etc.) has its own JVM implementation, which ensures that the same bytecode can run anywhere.

#### "Write Once, Run Anywhere" (WORA):
Developers write Java code once, and it can run on any system with a JVM, without requiring changes to the code.

### What is Bytecode?
Bytecode is the intermediate, platform-independent representation of Java code that is generated after compilation by the Java compiler (`javac`).

---

## 4. Six Steps During Java Compilation
The six steps during Java compilation involve transforming Java source code into bytecode. Here’s a breakdown:

1. **Lexical Analysis:**
   - The compiler scans the source code to break it into tokens (e.g., keywords, identifiers, operators, etc.).
   - Tokens are the basic building blocks of the program.
   - Errors like invalid characters or missing semicolons are detected here.

2. **Syntax Analysis (Parsing):**
   - Tokens are arranged into a syntax tree based on Java's grammar rules.
   - The compiler checks for syntactical correctness (e.g., missing parentheses or curly braces).
   - Syntax errors are reported at this stage.

3. **Semantic Analysis:**
   - The compiler checks the meaning and context of the code.
   - Ensures that variables are declared before use, types are compatible, and method calls match their definitions.
   - Errors like type mismatches or undefined variables are caught here.

4. **Intermediate Code Generation:**
   - The compiler generates an intermediate representation of the code in a low-level, platform-independent form (bytecode).
   - This bytecode will later be executed by the JVM.

5. **Optimization:**
   - The compiler optimizes the intermediate code to improve performance without changing its behavior.
   - Examples include removing redundant code or reordering instructions for efficiency.

6. **Code Generation:**
   - The optimized intermediate code is written to `.class` files as bytecode.
   - This bytecode is platform-independent and ready for execution by the JVM.

---

## 5. What is OOP? Why Do We Use OOP?
**Object-Oriented Programming (OOP)** is a programming paradigm that models software design around real-world objects and their interactions. Each object encapsulates data (attributes) and behavior (methods).

### Why Use OOP?
1. **Modularity:** Code is organized into objects, making it easier to maintain and modify.
2. **Reusability:** Classes and methods can be reused across projects.
3. **Scalability:** Encourages the creation of extensible systems.
4. **Maintainability:** Changes in one part of the system do not affect others due to encapsulation.

### OOP Principles
1. **Encapsulation:** Hides internal state and functionality, exposing only necessary parts.
2. **Abstraction:** Focuses on essential qualities while hiding implementation details.
3. **Inheritance:** Allows classes to inherit properties and behavior from parent classes.
4. **Polymorphism:** Enables objects to be treated as instances of their parent class.

---

## 6. SOLID Principles
The SOLID principles are a set of design principles that help developers create maintainable and scalable software systems:

1. **Single Responsibility Principle (SRP):** A class should have only one reason to change.
2. **Open/Closed Principle (OCP):** Classes should be open for extension but closed for modification.
3. **Liskov Substitution Principle (LSP):** Subtypes should be substitutable for their base types.
4. **Interface Segregation Principle (ISP):** A class should not be forced to implement interfaces it does not use.
5. **Dependency Inversion Principle (DIP):** High-level modules should not depend on low-level modules. Both should depend on abstractions.

---

## 7. What is IoC (Inversion of Control)?
Inversion of Control (IoC) is a design principle in which the control of object creation and dependency management is transferred from the program to a framework or container.

### Benefits of IoC:
1. **Decoupling:** Reduces dependencies between components.
2. **Flexibility:** Makes applications easier to extend and maintain.
3. **Testability:** Simplifies unit testing by allowing mock dependencies.

---

## 8. What is Dependency Injection (DI)? Why Do We Use It?
Dependency Injection (DI) is a design pattern where a class receives its dependencies from an external source rather than creating them itself.

### Why Use Dependency Injection?
1. **Reduces Coupling:** Promotes loose coupling between components.
2. **Enhances Testability:** Simplifies unit testing by injecting mock dependencies.
3. **Improves Maintainability:** Dependencies can be swapped without modifying the dependent class.

---

## 9. What is Mutable and Immutable?
- **Mutable:** Objects whose state can be modified after creation (e.g., `ArrayList`, `StringBuilder`).
- **Immutable:** Objects whose state cannot be changed after creation (e.g., `String`, `Integer`).

### Benefits of Immutable Objects:
1. **Thread-Safety:** Immutable objects can be shared across threads without synchronization.
2. **Predictability:** Reduces unintended side effects by ensuring the object’s state does not change.

---

## 10. Difference Between Abstract Class and Interface
| **Feature**                | **Abstract Class**                                     | **Interface**                            |
|----------------------------|-------------------------------------------------------|------------------------------------------|
| Inheritance                | Supports single inheritance.                          | Supports multiple inheritance.           |
| Default Methods            | Can have default methods.                            | Can have default and static methods.     |
| Fields                     | Can have instance variables.                         | Only allows `public static final` fields.|
| Use Case                   | Used for common functionality between classes.      | Used for defining contracts.             |

---

## 11. What is Composition? Why Prefer Composition Over Inheritance?
- **Composition:** A design principle where objects are composed of other objects rather than inheriting from them.

### Why Prefer Composition?
1. **Flexibility:** Allows behavior to be changed at runtime by composing different objects.
2. **Avoids Tight Coupling:** Reduces dependency on a specific class hierarchy.
3. **Follows Favor Composition Over Inheritance Principle:** Avoids issues like the diamond problem.

---

## 12. How Does HashMap Work in Java (In Depth)?
1. **Key-Value Pairs:** Stores data in key-value pairs using a hashing mechanism.
2. **Hashing:** Converts the key into a hash code, determining the bucket location.
3. **Collision Resolution:** Uses linked lists or balanced trees for handling collisions.
4. **Performance:** Time complexity for retrieval is O(1) in the best case and O(n) in the worst case.

---

## 13. Difference Between Session and Cookies
| **Aspect**       | **Session**                     | **Cookies**                     |
|------------------|--------------------------------|---------------------------------|
| Storage          | Server-side                    | Client-side                    |
| Security         | More secure                   | Less secure                    |
| Size Limit       | Limited by server resources    | Limited to 4KB                 |

---

## 14. HTTP Status Codes Meaning
- **1xx:** Informational.
- **2xx:** Success (e.g., 200 OK, 201 Created).
- **3xx:** Redirection (e.g., 301 Moved Permanently).
- **4xx:** Client Errors (e.g., 404 Not Found).
- **5xx:** Server Errors (e.g., 500 Internal Server Error).

---

## 15. What Happens When Facebook.com is Typed in Browsers? How It Works?
1. **DNS Resolution:** Converts the domain name to an IP address.
2. **TCP Handshake:** Establishes a connection between the browser and the server.
3. **HTTP Request:** Sends an HTTP request to the server.
4. **Server Response:** Receives the HTML, CSS, and JavaScript.
5. **Rendering:** Displays the webpage.

---

## 16. What is DNS?
The Domain Name System (DNS) translates human-readable domain names (e.g., `facebook.com`) into IP addresses required by devices to communicate over the internet.











## 17. 1. TCP and UDP Difference

- **TCP (Transmission Control Protocol)**: 
    - Connection-oriented
    - Ensures data is delivered in order and without loss.
    - Slower than UDP due to error checking, retransmission, and flow control.

- **UDP (User Datagram Protocol)**:
    - Connectionless
    - Doesn't guarantee data delivery, order, or error correction.
    - Faster than TCP.

## 18.  What is Heap? How to Construct a MaxHeap

- **Heap**: A special tree-based data structure that satisfies the heap property.
    - Max Heap: Parent nodes have greater value than child nodes.

**MaxHeap Construction**:
```java
class MaxHeap {
    private int[] heap;
    private int size;
    
    public MaxHeap(int capacity) {
        heap = new int[capacity];
        size = 0;
    }

    public void insert(int value) {
        heap[size] = value;
        size++;
        heapifyUp(size - 1);
    }

    private void heapifyUp(int index) {
        while (index > 0 && heap[index] > heap[(index - 1) / 2]) {
            int temp = heap[index];
            heap[index] = heap[(index - 1) / 2];
            heap[(index - 1) / 2] = temp;
            index = (index - 1) / 2;
        }
    }
}
```

## 19. HeapSort

HeapSort uses a MaxHeap to sort an array:

```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        MaxHeap heap = new MaxHeap(arr.length);
        for (int value : arr) {
            heap.insert(value);
        }
        for (int i = arr.length - 1; i >= 0; i--) {
            arr[i] = heap.removeMax();
        }
    }
}
```

## 20. Binary Search Tree (BST), Its Complexity and Worst Case

- **Binary Search Tree (BST)**: A binary tree where the left child is less than the parent and the right child is greater than the parent.

**Complexity**:
- Search, insert, delete: **O(log n)** in average case.
- **Worst Case**: O(n) when the tree becomes unbalanced (e.g., a linked list).

## 21. Quicksort

- **Quicksort**: A divide-and-conquer algorithm.
- **Time Complexity**: Average case **O(n log n)**, worst case **O(n²)**.

```java
public class QuickSort {
    public static void quicksort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quicksort(arr, low, pi - 1);
            quicksort(arr, pi + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }
}
```

## 22. Merge Sort

- **Merge Sort**: A divide-and-conquer algorithm.
- **Time Complexity**: **O(n log n)** for both worst and average cases.

```java
public class MergeSort {
    public static void mergeSort(int[] arr) {
        if (arr.length < 2) return;
        int mid = arr.length / 2;
        int[] left = Arrays.copyOfRange(arr, 0, mid);
        int[] right = Arrays.copyOfRange(arr, mid, arr.length);
        mergeSort(left);
        mergeSort(right);
        merge(arr, left, right);
    }

    private static void merge(int[] arr, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) arr[k++] = left[i++];
            else arr[k++] = right[j++];
        }
        while (i < left.length) arr[k++] = left[i++];
        while (j < right.length) arr[k++] = right[j++];
    }
}
```

## 23. Lazy Loading and Eager Loading in Spring

- **Lazy Loading**: Data is loaded only when it's needed.
- **Eager Loading**: Data is loaded immediately when the object is created.

## 24. Indexing Works

Indexing speeds up data retrieval operations but may slow down data insertion and update operations.

## 25. Which Column Should Be Indexed?

- Columns that are frequently used in `WHERE`, `JOIN`, and `ORDER BY` clauses.
- Columns used for foreign key relationships.

## 26. ACID Properties in Databases


ACID properties are a set of principles that ensure the reliability, consistency, and integrity of a database during transaction processing. The acronym stands for **Atomicity, Consistency, Isolation, and Durability**.

### Atomicity:
- **Definition**: A transaction is treated as a single, indivisible unit that either completes entirely or does not execute at all.  
- **Example**: In a bank transfer, if money is debited from one account but fails to credit another, the transaction will be rolled back, leaving both accounts unchanged.

### Consistency
- **Definition**: A transaction must transition the database from one valid state to another, preserving all predefined rules and constraints.  
- **Example**: If a database enforces a rule that no account balance can be negative, a transaction attempting to violate this rule will fail.

### Isolation
- **Definition**: Transactions occurring simultaneously do not interfere with each other. The outcome of a transaction is independent of other concurrently executed transactions.  
- **Example**: If two users are booking the last seat on a flight at the same time, only one transaction will succeed.

### Durability
- **Definition**: Once a transaction is committed, the changes are permanent, even in the case of a system crash.  
- **Example**: After successfully transferring money between accounts, the update remains intact, even if the database crashes immediately afterward.

These properties are fundamental to relational database systems like **MySQL**, **PostgreSQL**, and **Oracle**, and ensure data integrity and reliability in critical applications.


## 27. Normalization

Normalization reduces data redundancy by organizing data into tables according to certain rules, ensuring each table has only one topic and eliminating the repetition of data.

## 28. RDBS vs NoSQL

- **RDBMS**: Relational Database Management Systems (e.g., MySQL, PostgreSQL).
- **NoSQL**: Non-relational databases (e.g., MongoDB, Cassandra), typically used for unstructured or semi-structured data.

## 29. Join Queries

SQL queries used to combine rows from two or more tables based on a related column.

```sql
SELECT * FROM employees 
JOIN departments ON employees.department_id = departments.id;
```

## 30. Indexing Disadvantages and Solutions

- **Disadvantages**:
  - Slows down `INSERT`, `UPDATE`, and `DELETE` operations.
  - Uses additional disk space.
  
- **Solutions**:
  - Use indexing on columns that are frequently queried, not on every column.
  - Use composite indexes.

## 31. Indexing on a Column with 100 Million Rows

For a large number of rows, indexing helps speed up query performance but may slow down insert/update operations. Use indexing on frequently queried fields and consider partitioning the data.

## 32. Complete Binary Tree, Full Binary Tree Definitions

- **Complete Binary Tree**: A binary tree where all levels are fully filled except possibly the last, and all nodes are as left as possible.
- **Full Binary Tree**: Every node has either 0 or 2 children.

## 33. Array vs LinkedList

- **Array**: Fixed size, contiguous memory allocation, random access.
- **LinkedList**: Dynamic size, non-contiguous memory allocation, slower random access.

## 34. Queue, Stack, Priority Queue

- **Queue**: First In First Out (FIFO).
- **Stack**: Last In First Out (LIFO).
- **Priority Queue**: Elements are ordered by priority.

## 35. Compiler vs Interpreter, Strongly Typed vs Weakly Typed Languages

- **Compiler**: Translates code into machine code before execution.
- **Interpreter**: Executes code line by line.

- **Strongly Typed**: Variables are explicitly defined.
- **Weakly Typed**: Variable types can be implicitly changed.

## 36. Session vs JWT

- **Session**: Server-side storage of session data.
- **JWT**: Client-side storage of user authentication information in a token.

## 37. Functional Interface

A functional interface in Java is an interface that has only one abstract method.

## 38. Lambda Functions

Lambda expressions allow you to create instances of functional interfaces in a more concise manner.

```java
Runnable r = () -> System.out.println("Hello, World!");
```

## 39. Stream API

Java 8 introduced Streams for processing sequences of elements in a functional style.

```java
List<String> names = Arrays.asList("John", "Jane", "Doe");
names.stream().filter(name -> name.startsWith("J")).forEach(System.out::println);
```

## 40. Mutable vs Immutable

- **Mutable**: Object whose state can be changed.
- **Immutable**: Object whose state cannot be changed once created.

## 41. Java Pass By Value or Pass By Reference?

Java is always **pass by value**. However, when objects are passed, the value is a reference to the object, so the object's state can be modified, but the reference itself cannot be changed.

## 42. Deep Copy vs Shallow Copy

- **Shallow Copy**: Copies only the references of objects.
- **Deep Copy**: Copies the objects themselves, not just their references.

## 43. Multiple Inheritance in Java

Java does not support multiple inheritance directly to avoid ambiguity and complexity. However, it can be achieved using interfaces.

## 44. Operator Overloading in Java

Java does not support operator overloading to maintain simplicity and readability.



## 45. Rest API and Its Principles

- **REST API (Representational State Transfer)** is an architectural style for designing networked applications. It uses HTTP requests to perform CRUD operations.
  
**Principles of REST**:
- **Stateless**: No client context is stored on the server between requests.
- **Uniform Interface**: A consistent interface is used for communication.
- **Cacheable**: Responses must explicitly define themselves as cacheable or not.
- **Client-Server**: Separation between the client and the server to allow independent development.
- **Layered System**: The system is composed of hierarchical layers.
- **Code on Demand (optional)**: Servers can provide executable code to clients (e.g., JavaScript).

## 46. All Types of Joins in SQL

- **INNER JOIN**: Returns records that have matching values in both tables.
  
```sql
SELECT * FROM employees 
INNER JOIN departments ON employees.department_id = departments.id;
```

- **LEFT JOIN (or LEFT OUTER JOIN)**: Returns all records from the left table, and matched records from the right table.

```sql
SELECT * FROM employees 
LEFT JOIN departments ON employees.department_id = departments.id;
```

- **RIGHT JOIN (or RIGHT OUTER JOIN)**: Returns all records from the right table, and matched records from the left table.

```sql
SELECT * FROM employees 
RIGHT JOIN departments ON employees.department_id = departments.id;
```

- **FULL JOIN (or FULL OUTER JOIN)**: Returns records when there is a match in either left or right table.

```sql
SELECT * FROM employees 
FULL OUTER JOIN departments ON employees.department_id = departments.id;
```

- **CROSS JOIN**: Returns the Cartesian product of both tables.

```sql
SELECT * FROM employees 
CROSS JOIN departments;
```

## 47. Singleton Design Pattern

The **Singleton Pattern** ensures a class has only one instance and provides a global point of access.

```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

## 48. Factory Design Pattern

The **Factory Design Pattern** provides an interface for creating objects, but allows subclasses to alter the type of objects that will be created.

```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() {
        System.out.println("Bark");
    }
}

class Cat implements Animal {
    public void sound() {
        System.out.println("Meow");
    }
}

class AnimalFactory {
    public static Animal getAnimal(String animalType) {
        if (animalType.equals("Dog")) {
            return new Dog();
        } else if (animalType.equals("Cat")) {
            return new Cat();
        }
        return null;
    }
}
```

## 49. Abstract Factory Design Pattern

The **Abstract Factory Design Pattern** provides an interface for creating families of related or dependent objects without specifying their concrete classes.

```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() {
        System.out.println("Bark");
    }
}

class Cat implements Animal {
    public void sound() {
        System.out.println("Meow");
    }
}

interface AnimalFactory {
    Animal createAnimal();
}

class DogFactory implements AnimalFactory {
    public Animal createAnimal() {
        return new Dog();
    }
}

class CatFactory implements AnimalFactory {
    public Animal createAnimal() {
        return new Cat();
    }
}
```

## 50. Adapter Pattern

The **Adapter Pattern** allows incompatible interfaces to work together. It acts as a bridge between two objects.

```java
interface MediaPlayer {
    void play(String mediaType);
}

class MP4Player implements MediaPlayer {
    public void play(String mediaType) {
        System.out.println("Playing MP4 file");
    }
}

interface MediaAdapter {
    void playMedia(String mediaType);
}

class MediaAdapterImpl implements MediaAdapter {
    private MediaPlayer mediaPlayer;

    public MediaAdapterImpl(String mediaType) {
        if(mediaType.equals("MP4")) {
            mediaPlayer = new MP4Player();
        }
    }

    public void playMedia(String mediaType) {
        mediaPlayer.play(mediaType);
    }
}
```

## 51. MVC Pattern

The **Model-View-Controller (MVC)** pattern separates an application into three interconnected components:
- **Model**: Represents the data.
- **View**: Displays the data.
- **Controller**: Handles user input and updates the model and view.

```java
// Model
class UserModel {
    private String name;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

// View
class UserView {
    public void printUserDetails(String name) {
        System.out.println("User: " + name);
    }
}

// Controller
class UserController {
    private UserModel model;
    private UserView view;
    
    public UserController(UserModel model, UserView view) {
        this.model = model;
        this.view = view;
    }
    
    public void setUserName(String name) {
        model.setName(name);
    }
    
    public void updateView() {
        view.printUserDetails(model.getName());
    }
}
```

## 52. Java Access Modifiers

Java provides four access modifiers:
- **private**: Accessible only within the class.
- **default (no modifier)**: Accessible within the same package.
- **protected**: Accessible within the same package and subclasses.
- **public**: Accessible from any class.

## 53. Second Highest Salary in SQL

```sql
SELECT MAX(salary) AS second_highest
FROM employees
WHERE salary < (SELECT MAX(salary) FROM employees);
```

## 54. Manager Employee in SQL

To select a manager and their employees:

```sql
SELECT e.name AS Employee, m.name AS Manager
FROM employees e
JOIN employees m ON e.manager_id = m.id;
```

## 55. Git Fetch and Merge Difference

- **git fetch**: Downloads new data from a remote repository without merging it into your working files.
- **git merge**: Combines the changes from two branches into one.

## 56. Struct vs Class in C++

- **Struct**: In C++, members are public by default.
- **Class**: In C++, members are private by default.

## 57. Difference Between Asynchronous, Parallelism, and Concurrency

- **Asynchronous**: Tasks are executed without blocking the main thread, but not necessarily in parallel.
- **Parallelism**: Tasks are executed at the same time on multiple processors.
- **Concurrency**: Multiple tasks are being processed, but not necessarily at the same time; they may be interleaved.

```

